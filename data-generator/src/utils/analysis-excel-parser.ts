import * as XLSX from 'xlsx';
import { AIAnalysisResult, UserSegment, Transaction } from '../types';

/**
 * Parse AI analysis Excel files back into data structures
 * Reads the Excel files generated by AnalysisExcelGenerator
 */
export class AnalysisExcelParser {
  /**
   * Parse the uploaded AI analysis Excel file
   */
  async parseAnalysisExcel(filePath: string): Promise<Partial<AIAnalysisResult>> {
    const workbook = XLSX.readFile(filePath);

    const result: Partial<AIAnalysisResult> = {};

    // Parse Sheet 1: User Segments
    const segmentSheetName = '1_ì‚¬ìš©ì_ì„¸ê·¸ë¨¼íŠ¸';
    if (workbook.SheetNames.includes(segmentSheetName)) {
      result.userSegments = this.parseUserSegments(workbook.Sheets[segmentSheetName]) as any;
      result.sessionPatterns = this.parseSessionPatterns(workbook.Sheets[segmentSheetName]);
    }

    // Parse Sheet 2: Event Sequencing (partial - complex structure)
    const sequencingSheetName = '2_ì´ë²¤íŠ¸_ìˆœì„œ_ê·œì¹™';
    if (workbook.SheetNames.includes(sequencingSheetName)) {
      result.eventSequencing = this.parseEventSequencing(workbook.Sheets[sequencingSheetName]);
    }

    // Parse Sheet 3: Transactions (if exists)
    const transactionSheetName = '3_íŠ¸ëœì­ì…˜_ì •ì˜';
    if (workbook.SheetNames.includes(transactionSheetName)) {
      const transactions = this.parseTransactions(workbook.Sheets[transactionSheetName]);
      if (result.eventSequencing) {
        result.eventSequencing.transactions = transactions;
      } else {
        result.eventSequencing = { transactions } as any;
      }
    }

    return result;
  }

  /**
   * Parse user segments from sheet 1
   */
  private parseUserSegments(sheet: XLSX.WorkSheet): UserSegment[] {
    const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    const segments: UserSegment[] = [];

    // Find the header row (contains "ì„¸ê·¸ë¨¼íŠ¸ëª…")
    let headerRowIndex = -1;
    for (let i = 0; i < data.length; i++) {
      if (data[i]?.includes('ì„¸ê·¸ë¨¼íŠ¸ëª…')) {
        headerRowIndex = i;
        break;
      }
    }

    if (headerRowIndex === -1) {
      console.warn('âš ï¸ User segment header not found');
      return [];
    }

    // Parse data rows (skip header)
    for (let i = headerRowIndex + 1; i < data.length; i++) {
      const row = data[i];

      // Stop at empty rows or footer
      if (!row || row.length === 0 || row[0]?.toString().startsWith('ğŸ’¡')) {
        break;
      }

      const name = row[0]?.toString();
      const ratioPercent = parseFloat(row[1]?.toString() || '0');
      const characteristics = row[2]?.toString() || '';

      if (name && !isNaN(ratioPercent)) {
        segments.push({
          name,
          ratio: ratioPercent / 100, // Convert percentage to decimal
          characteristics
        });
      }
    }

    console.log(`ğŸ“Š Parsed ${segments.length} user segments`);
    return segments;
  }

  /**
   * Parse session patterns from sheet 1
   */
  private parseSessionPatterns(sheet: XLSX.WorkSheet): any {
    const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    const patterns: any = {
      avgSessionsPerDay: {},
      avgSessionDuration: {},
      avgEventsPerSession: {}
    };

    // Find the header row
    let headerRowIndex = -1;
    for (let i = 0; i < data.length; i++) {
      if (data[i]?.includes('ì„¸ê·¸ë¨¼íŠ¸ëª…')) {
        headerRowIndex = i;
        break;
      }
    }

    if (headerRowIndex === -1) {
      return patterns;
    }

    // Parse data rows
    for (let i = headerRowIndex + 1; i < data.length; i++) {
      const row = data[i];

      if (!row || row.length === 0 || row[0]?.toString().startsWith('ğŸ’¡')) {
        break;
      }

      const name = row[0]?.toString();
      if (!name) continue;

      patterns.avgSessionsPerDay[name] = parseFloat(row[3]?.toString() || '0');
      patterns.avgSessionDuration[name] = parseFloat(row[4]?.toString() || '0') * 1000 * 60; // Convert minutes to ms
      patterns.avgEventsPerSession[name] = parseInt(row[5]?.toString() || '0');
    }

    return patterns;
  }

  /**
   * Parse event sequencing from sheet 2 (simplified version)
   */
  private parseEventSequencing(sheet: XLSX.WorkSheet): any {
    const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    const sequencing: any = {
      eventCategories: {},
      strictDependencies: {},
      executionConstraints: {},
      logicalSequences: []
    };

    // Parse event categories
    let inCategorySection = false;
    let inDependencySection = false;
    let inConstraintSection = false;

    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      if (!row || row.length === 0) continue;

      const firstCell = row[0]?.toString() || '';

      // Detect sections
      if (firstCell.includes('ì´ë²¤íŠ¸ ì¹´í…Œê³ ë¦¬')) {
        inCategorySection = true;
        inDependencySection = false;
        inConstraintSection = false;
        i++; // Skip header row
        continue;
      } else if (firstCell.includes('í•„ìˆ˜ ì„ í–‰ ì´ë²¤íŠ¸')) {
        inCategorySection = false;
        inDependencySection = true;
        inConstraintSection = false;
        i++; // Skip header row
        continue;
      } else if (firstCell.includes('ì‹¤í–‰ ì œì•½')) {
        inCategorySection = false;
        inDependencySection = false;
        inConstraintSection = true;
        i++; // Skip header row
        continue;
      } else if (firstCell.startsWith('ğŸ’¡')) {
        break; // End of data
      }

      // Parse based on current section
      if (inCategorySection) {
        const category = row[0]?.toString();
        const events = row[1]?.toString().split(',').map((e: string) => e.trim()).filter(Boolean);
        if (category && events.length > 0) {
          sequencing.eventCategories[category] = events;
        }
      } else if (inDependencySection) {
        const event = row[0]?.toString();
        const deps = row[1]?.toString().split(',').map((d: string) => d.trim()).filter(Boolean);
        if (event && deps.length > 0) {
          sequencing.strictDependencies[event] = deps;
        }
      } else if (inConstraintSection) {
        const event = row[0]?.toString();
        const constraintType = row[1]?.toString();
        const constraintValue = row[2];

        if (event && constraintType) {
          if (!sequencing.executionConstraints[event]) {
            sequencing.executionConstraints[event] = {};
          }

          if (constraintType.includes('ì„¸ì…˜ë‹¹ ìµœëŒ€ íšŸìˆ˜')) {
            sequencing.executionConstraints[event].maxOccurrencesPerSession = parseInt(constraintValue?.toString() || '0');
          } else if (constraintType.includes('ìœ ì €ë‹¹ ìµœëŒ€ íšŸìˆ˜')) {
            sequencing.executionConstraints[event].maxOccurrencesPerUser = parseInt(constraintValue?.toString() || '0');
          } else if (constraintType.includes('ì²« ì„¸ì…˜ ì „ìš©')) {
            sequencing.executionConstraints[event].requiresFirstSession = true;
          } else if (constraintType.includes('ì°¨ë‹¨ ê·œì¹™')) {
            const blockedEvents = constraintValue?.toString().split(',').map((e: string) => e.trim()).filter(Boolean);
            sequencing.executionConstraints[event].blockedAfterEvents = blockedEvents;
          }
        }
      }
    }

    console.log(`ğŸ“Š Parsed event sequencing:`, {
      categories: Object.keys(sequencing.eventCategories).length,
      dependencies: Object.keys(sequencing.strictDependencies).length,
      constraints: Object.keys(sequencing.executionConstraints).length
    });

    return sequencing;
  }

  /**
   * Parse transactions from sheet 3
   */
  private parseTransactions(sheet: XLSX.WorkSheet): Transaction[] {
    const data: any[][] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    const transactions: Transaction[] = [];

    // Find the header row
    let headerRowIndex = -1;
    for (let i = 0; i < data.length; i++) {
      if (data[i]?.includes('íŠ¸ëœì­ì…˜ëª…')) {
        headerRowIndex = i;
        break;
      }
    }

    if (headerRowIndex === -1) {
      console.warn('âš ï¸ Transaction header not found');
      return [];
    }

    // Parse data rows
    for (let i = headerRowIndex + 1; i < data.length; i++) {
      const row = data[i];

      if (!row || row.length === 0 || row[0]?.toString().startsWith('ğŸ’¡') || row[0]?.toString().startsWith('ì˜ˆì‹œ')) {
        break;
      }

      const name = row[0]?.toString();
      const description = row[1]?.toString() || '';
      const startEvents = row[2]?.toString().split(',').map((e: string) => e.trim()).filter(Boolean) || [];
      const endEvents = row[3]?.toString().split(',').map((e: string) => e.trim()).filter(Boolean) || [];
      const innerEvents = row[4]?.toString().split(',').map((e: string) => e.trim()).filter(Boolean) || [];
      const allowInnerAfterEnd = row[5]?.toString().includes('í—ˆìš©');

      if (name && startEvents.length > 0 && endEvents.length > 0) {
        transactions.push({
          name,
          description,
          startEvents,
          endEvents,
          innerEvents,
          allowInnerAfterEnd
        });
      }
    }

    console.log(`ğŸ“Š Parsed ${transactions.length} transactions`);
    return transactions;
  }
}
